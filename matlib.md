# Как компьютер считает различные функции
  В математике есть очень много различных функций с различным смыслом. Но у компьютера есть доступ только к базовым арифметическим операциям (сложение, вычитание, умножение, деление). В этой статье я покажу и расскажу про все приёмы для их реализаций. Я буду писать код на ~~C~~ Rust.
## Квадратный корень
### Метод половинного деления
Его смысл заключается в том, чтобы запереть число в некоторые рамки, а потом их сужать. Для начала можно взять рамки из 2 ближайших корней с натуральным результатом. Пусть $a$ будет число, а $x=\sqrt{a}$. $a=7$, тогда $\sqrt{4}<x<\sqrt{9}\iff 2<x<3$. Возьмем среднее от 2 и 3, это будет 2.5 и проверим догадку $2.5^2=6.25$ $6.25 < 7$, тогда обновим рамки $2.5<x<3$ и снова найдём среднее значение $\frac{2.5+3}{2}=2.75$, $2.75^2=7.5625<7$. Так можно повторять сколько угодно раз и получить точное значение
```Rust
fn sqrt(a : f32, iter : usize) -> f32 {
	if a < 0.0 {
		panic!("Negative square root"); // при отрицательных значениях
	}
	if a == 0.0 || a == 1.0 {
		return  a;
	}
	let mut max == 0.0;
	while max * max < a {
		max += 1.0;	
	}
	let mut min = max - 1.0;
	for _ in 0..iter {
		let x = (max + min) / 2.0;
		
		if x * x == a {
			return x;
		}
		else if x * x > a {
			max = x;
		}
		else if x * x < a {
			min = x;
		}
	}
	return (min  +  max) /  2.0;
}
```
### Метод Ньютона
  Для начала можно посмотреть на свойства квадратного корня, $(\sqrt{a})^2=a\iff \sqrt{a} \cdot \sqrt{a}=a\iff\sqrt{a}=\frac{a}{\sqrt{a}}$. От приближения и отношения числа к приближению можно взять среднее. И описать действия так:
#### $x_{n+1}=0.5(x_n+\frac{a}{x_n})$
Осталось лишь выбрать способ нахождения $x_0$. Я возьму переменную `max` из прошлой функции
```Rust
fn sqrt(a : f32, iter : usize) -> f32 {
	if a < 0.0 {
		panic!("Negative square root"); // при отрицательных значениях
	}
	if a == 0.0 || a == 1.0 {
		return  a;
	}
	let mut x = 0.0;
	while x * x < a {
		x += 1.0;	
	}
	for _ in 0..iter {
		x = 0.5 * (x + a / x);
	}
	return x;
}
```
### Секретный метод
  Эта часть появилась только благодаря юмористам с моего [Telegram канала](https://t.me/matkrieg).
```Rust
use rand::prelude::*;

fn sqrt(a : f32, iter : usize) -> f32 {
	let mut x : f32 = 0.0;
	let mut rng = rand::thread_rng();
	for _ in 0..iter {
		x = rng.gen().pow(2.0) * a;
	}
	return x;
}
```
## Тригонометрические функции
### Синус и Косинус
Тут я решил обойтись рядом Тейлора и взял 6 членов.
```Rust
fn sin(a : f32) -> f32 {
	let aa = a*a;
	return a - a*aa/6.0 + a*aa*aa/120.0 - 
	a*aa*aa*aa/5040.0 + a*aa*aa*aa*aa/362880.0 -
	a*aa*aa*aa*aa*aa/39916800.0;
}
fn cos(a : f32) -> f32 {
	let aa = a*a;
	return 1.0 - aa/2.0 + aa*aa/24.0 - aa*aa*aa/720.0 +
	aa*aa*aa*aa/40320.0 - aa*aa*aa*aa*aa/3628800.0 +
	aa*aa*aa*aa*aa*aa/479001600.0;
}
```
### Тангенс и Котангенс
В этом случае можно обойтись делением прошлых функций на себя, но это может быть не так быстро, как я хочу. Я нашел вот такую реализацию:
```Rust
fn tan(a : f32) -> f32 {
	let aa = a*a;
	let mut term = a;
	let mut result = a;
	for n in 1..7 {
		term *= -aa * (2 * n - 1) / (2 * n + 1);
		result += term; 
	}
	return result;
}
```
Функцию котангенса ~~мне лень писать~~ можно реализовать на основе функции тангенса с минимальными затратами:
```Rust
fn cot(a : f32) -> f32 {
	return 1.0 / tan(a);
}
```
## Логарифмы
  Для начала рассмотрим натуральный логарифм. Я решил использовать обычный ряд и немного его улучшить. Чем будет число ближе к точке Абеля (1), тем точнее результат. По свойству логарифмов $\ln(a^b)=b\cdot\ln(a)$ можно приближать результат к ней таким образом: $\ln(a)=\ln((\sqrt a)^2)=2\cdot\ln(\sqrt a)$ Таким образом можно внести $a$ в рамки с наиболее точными результатами. Для 12 членов достаточно рамок $0.6<x<1.4$
```Rust
fn ln(x : f32) -> f32 {
	if x <= 0.0 {
		panic!("Unpositive logarithm");
	}
	let mut mx = x;
	let mut mp = 1.0;
	while mx > 1.4 || mx < 0.6 { // запираю в рамки
		mp *= 2.0;
		mx = sqrt(mx);
	}
	mx -= 1.0; // вычитаю 1, так как в ряде ln(1+x) 
	return mp * (mx 
	 - mx*mx/2.0 
	 + mx*mx*mx/3.0 
	 - mx*mx*mx*mx/4.0 
	 + mx*mx*mx*mx*mx/5.0 
	 - mx*mx*mx*mx*mx*mx/6.0 
	 + mx*mx*mx*mx*mx*mx*mx/7.0
	 - mx*mx*mx*mx*mx*mx*mx*mx/8.0
	 + mx*mx*mx*mx*mx*mx*mx*mx*mx/9.0
	 - mx*mx*mx*mx*mx*mx*mx*mx*mx*mx/10.0
	 + mx*mx*mx*mx*mx*mx*mx*mx*mx*mx*mx/11.0
	 - mx*mx*mx*mx*mx*mx*mx*mx*mx*mx*mx*mx/12.0);
}
```
  Для  логарифма с произвольным основанием можно воспользоваться другим свойством $\log_ba=\frac{\ln(a)}{\ln(b)}$.
```Rust
fn log(a : f32, b : f32) -> f32 {
	if b == 1.0 {
		panic!("logarithm base is 1");
	}
	if a == 1 {
		return 0.0;
	}
	if a == b {
		return 1.0;
	}
	// защиты от отрицательных значений не будет, ведь она есть в прошлой функции
	return ln(a) / ln(b);
}
```
## Конец
Надеюсь вам понравилось вместе со мной реализовывать маленькую математическую библиотеку. Увидимся в следующей статье...